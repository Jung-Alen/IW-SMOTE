# -*- coding: utf-8 -*-
"""
Created on Sun Mar 29 10:59:58 2020

@author: 小小飞在路上
"""
import numpy as np
from sklearn.preprocessing import OneHotEncoder


class RELM_HiddenLayer:
    """
        正则化的极限学习机
        :param xmin: 少数类样本
        :param xmaj: 多数类样本
        :param xsyn: 合成样本
        :param num: 学习机隐层节点数
        :param C: 正则化系数的倒数
    """

    def __init__(self, xmin, xmaj, xsyn, num, C=10):
        ##少数类样本的P
        row = xmin.shape[0]
        columns = xmin.shape[1]
        rnd = np.random.RandomState()
        # xmin权重w
        self.wmin = rnd.uniform(-1, 1, (columns, num))
        # xmin偏置b
        self.bmin = np.zeros([row, num], dtype=float)
        for i in range(num):
            rand_b = rnd.uniform(-0.4, 0.4)
            for j in range(row):
                self.bmin[j, i] = rand_b
        self.H0min = np.matrix(self.sigmoid(np.dot(xmin, self.wmin) + self.bmin))
        self.C = C
        self.Pmin = (self.H0min.H * self.H0min + len(xmin) / self.C).I
        # .T:转置矩阵,.H:共轭转置,.I:逆矩阵

        ## 多数类样本的HO，P
        row = xmaj.shape[0]
        columns = xmaj.shape[1]
        rnd = np.random.RandomState()
        # xmaj权重w
        self.wmaj = rnd.uniform(-1, 1, (columns, num))
        # xmaj偏置b
        self.bmaj = np.zeros([row, num], dtype=float)
        for i in range(num):
            rand_b = rnd.uniform(-0.4, 0.4)
            for j in range(row):
                self.bmaj[j, i] = rand_b
        self.H0maj = np.matrix(self.sigmoid(np.dot(xmaj, self.wmaj) + self.bmaj))
        self.Pmaj = (self.H0maj.H * self.H0maj + len(xmaj) / self.C).I
        # .T:转置矩阵,.H:共轭转置,.I:逆矩阵

        ## 合成类样本的HO，P
        row = xsyn.shape[0]
        columns = xsyn.shape[1]
        rnd = np.random.RandomState()
        # xsyn权重w
        self.wsyn = rnd.uniform(-1, 1, (columns, num))
        # xsyn偏置b
        self.bsyn = np.zeros([row, num], dtype=float)
        for i in range(num):
            rand_b = rnd.uniform(-0.4, 0.4)
            for j in range(row):
                self.bsyn[j, i] = rand_b
        self.H0maj = np.matrix(self.sigmoid(np.dot(xsyn, self.wsyn) + self.bsyn))
        self.Psyn = (self.H0syn.H * self.H0syn + len(xsyn) / self.C).I
        # .T:转置矩阵,.H:共轭转置,.I:逆矩阵

        self.Nmin = len(xmin)
        self.Nmaj = len(xmaj)
        self.N = len(xmin) + len(xmaj)


        # all权重w
        self.w = rnd.uniform(-1, 1, (columns, num))
        # all偏置b
        self.b = np.zeros([self.N, num], dtype=float)
        for i in range(num):
            rand_b = rnd.uniform(-0.4, 0.4)
            for j in range(self.N):
                self.b[j, i] = rand_b

    @staticmethod
    def sigmoid(x):
        """
            激活函数sigmoid
            :param x: 训练集中的X
            :return: 激活值
        """
        return 1.0 / (1 + np.exp(-x))


    # 分类问题 训练
    def classifisor_train(self, T):
        """
            初始化了学习机后需要传入对应标签T
            :param T: 对应属性X的标签T
            :return: 隐层输出权值beta
        """
        Cmaj = ((self.N - self.Nmaj) * self.C )/ self.N
        Cmin = ((self.N - self.Nmin) * self.C) / self.N
        Csyn = ((self.N - self.Nmin - self.Nmaj) * self.C) / self.N
        if len(T.shape) > 1:
            pass
        else:
            self.en_one = OneHotEncoder()
            T = self.en_one.fit_transform(T.reshape(-1, 1)).toarray()
            pass
        all_m = (1/Cmaj + 1/Cmin +1/Csyn + (1 + Cmaj/Cmin + Cmaj/Csyn)*np.dot(self.H0maj.T, self.H0maj) + (1 + Cmin/Cmaj + Cmin/Csyn)*np.dot(self.H0min.T, self.H0min) + (1 + Csyn/Cmaj + Csyn/Cmin)*np.dot(self.H0syn.T, self.H0syn))
        all_m = np.dot(all_m.T, all_m)
        self.beta = np.dot(all_m, T)
        return self.beta

    # 分类问题 测试
    def classifisor_test(self, test_x):
        """
            传入待预测的属性X并进行预测获得预测值
            :param test_x:被预测标签的属性X
            :return: 被预测标签的预测值T
        """
        b_row = test_x.shape[0]
        h = self.sigmoid(np.dot(test_x, self.w) + self.b[:b_row, :])
        result = np.dot(h, self.beta)
        result = np.argmax(result, axis=1)
        return result
